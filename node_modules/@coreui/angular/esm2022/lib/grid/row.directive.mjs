import { Directive, HostBinding, Input } from '@angular/core';
import { BreakpointInfix } from '../coreui.types';
import * as i0 from "@angular/core";
export class RowDirective {
    get hostClasses() {
        const cols = this.xs;
        const classes = {
            row: true,
            [`row-cols-${cols}`]: !!cols,
        };
        Object.keys(BreakpointInfix).forEach(breakpoint => {
            // @ts-ignore
            const value = this[breakpoint];
            if ((typeof value === 'number') || (typeof value === 'string')) {
                const infix = breakpoint === 'xs' ? '' : breakpoint;
                classes[`row-cols-${infix}-${value}`] = !!value;
            }
        });
        return classes;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.3", ngImport: i0, type: RowDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.2.3", type: RowDirective, isStandalone: true, selector: "[cRow]", inputs: { xs: "xs", sm: "sm", md: "md", lg: "lg", xl: "xl", xxl: "xxl" }, host: { properties: { "class": "this.hostClasses" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.3", ngImport: i0, type: RowDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cRow]',
                    standalone: true
                }]
        }], propDecorators: { xs: [{
                type: Input
            }], sm: [{
                type: Input
            }], md: [{
                type: Input
            }], lg: [{
                type: Input
            }], xl: [{
                type: Input
            }], xxl: [{
                type: Input
            }], hostClasses: [{
                type: HostBinding,
                args: ['class']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm93LmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2NvcmV1aS1hbmd1bGFyL3NyYy9saWIvZ3JpZC9yb3cuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUU5RCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0saUJBQWlCLENBQUM7O0FBT2xELE1BQU0sT0FBTyxZQUFZO0lBZ0N2QixJQUNJLFdBQVc7UUFFYixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBRXJCLE1BQU0sT0FBTyxHQUFRO1lBQ25CLEdBQUcsRUFBRSxJQUFJO1lBQ1QsQ0FBQyxZQUFZLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUk7U0FDN0IsQ0FBQztRQUVGLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ2hELGFBQWE7WUFDYixNQUFNLEtBQUssR0FBUSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDcEMsSUFBSSxDQUFDLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxLQUFLLEtBQUssUUFBUSxDQUFDLEVBQUUsQ0FBQztnQkFDL0QsTUFBTSxLQUFLLEdBQVcsVUFBVSxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUM7Z0JBQzVELE9BQU8sQ0FBQyxZQUFZLEtBQUssSUFBSSxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUM7WUFDbEQsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQzs4R0FwRFUsWUFBWTtrR0FBWixZQUFZOzsyRkFBWixZQUFZO2tCQUp4QixTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxRQUFRO29CQUNsQixVQUFVLEVBQUUsSUFBSTtpQkFDakI7OEJBTVUsRUFBRTtzQkFBVixLQUFLO2dCQUtHLEVBQUU7c0JBQVYsS0FBSztnQkFLRyxFQUFFO3NCQUFWLEtBQUs7Z0JBS0csRUFBRTtzQkFBVixLQUFLO2dCQUtHLEVBQUU7c0JBQVYsS0FBSztnQkFLRyxHQUFHO3NCQUFYLEtBQUs7Z0JBR0YsV0FBVztzQkFEZCxXQUFXO3VCQUFDLE9BQU8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3RCaW5kaW5nLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBCcmVha3BvaW50SW5maXggfSBmcm9tICcuLi9jb3JldWkudHlwZXMnO1xuaW1wb3J0IHsgSVJvdywgTnVtYmVyT2ZDb2x1bW5zIH0gZnJvbSAnLi9yb3cudHlwZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjUm93XScsXG4gIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgUm93RGlyZWN0aXZlIGltcGxlbWVudHMgSVJvdyB7XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMvb2Zmc2V0L29yZGVyIG9uIGV4dHJhIHNtYWxsIGRldmljZXMgKDw1NzZweCkuXG4gICAqIEB0eXBlIHt7IGNvbHM6ICdhdXRvJyB8IG51bWJlciB9XG4gICAqL1xuICBASW5wdXQoKSB4cz86IE51bWJlck9mQ29sdW1ucztcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgY29sdW1ucy9vZmZzZXQvb3JkZXIgb24gc21hbGwgZGV2aWNlcyAoPDc2OHB4KS5cbiAgICogQHR5cGUge3sgY29sczogJ2F1dG8nIHwgbnVtYmVyIH1cbiAgICovXG4gIEBJbnB1dCgpIHNtPzogTnVtYmVyT2ZDb2x1bW5zO1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBjb2x1bW5zL29mZnNldC9vcmRlciBvbiBtZWRpdW0gZGV2aWNlcyAoPDk5MnB4KS5cbiAgICogQHR5cGUge3sgY29sczogJ2F1dG8nIHwgbnVtYmVyIH1cbiAgICovXG4gIEBJbnB1dCgpIG1kPzogTnVtYmVyT2ZDb2x1bW5zO1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBjb2x1bW5zL29mZnNldC9vcmRlciBvbiBsYXJnZSBkZXZpY2VzICg8MTIwMHB4KS5cbiAgICogQHR5cGUge3sgY29sczogJ2F1dG8nIHwgbnVtYmVyIH1cbiAgICovXG4gIEBJbnB1dCgpIGxnPzogTnVtYmVyT2ZDb2x1bW5zO1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBjb2x1bW5zL29mZnNldC9vcmRlciBvbiBYLUxhcmdlIGRldmljZXMgKDwxNDAwcHgpLlxuICAgKiBAdHlwZSB7eyBjb2xzOiAnYXV0bycgfCBudW1iZXIgfVxuICAgKi9cbiAgQElucHV0KCkgeGw/OiBOdW1iZXJPZkNvbHVtbnM7XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMvb2Zmc2V0L29yZGVyIG9uIFhYLUxhcmdlIGRldmljZXMgKOKJpTE0MDBweCkuXG4gICAqIEB0eXBlIHt7IGNvbHM6ICdhdXRvJyB8IG51bWJlciB9XG4gICAqL1xuICBASW5wdXQoKSB4eGw/OiBOdW1iZXJPZkNvbHVtbnM7XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcycpXG4gIGdldCBob3N0Q2xhc3NlcygpOiBhbnkge1xuXG4gICAgY29uc3QgY29scyA9IHRoaXMueHM7XG5cbiAgICBjb25zdCBjbGFzc2VzOiBhbnkgPSB7XG4gICAgICByb3c6IHRydWUsXG4gICAgICBbYHJvdy1jb2xzLSR7Y29sc31gXTogISFjb2xzLFxuICAgIH07XG5cbiAgICBPYmplY3Qua2V5cyhCcmVha3BvaW50SW5maXgpLmZvckVhY2goYnJlYWtwb2ludCA9PiB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCB2YWx1ZTogYW55ID0gdGhpc1ticmVha3BvaW50XTtcbiAgICAgIGlmICgodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgfHwgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIGNvbnN0IGluZml4OiBzdHJpbmcgPSBicmVha3BvaW50ID09PSAneHMnID8gJycgOiBicmVha3BvaW50O1xuICAgICAgICBjbGFzc2VzW2Byb3ctY29scy0ke2luZml4fS0ke3ZhbHVlfWBdID0gISF2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjbGFzc2VzO1xuICB9XG59XG4iXX0=