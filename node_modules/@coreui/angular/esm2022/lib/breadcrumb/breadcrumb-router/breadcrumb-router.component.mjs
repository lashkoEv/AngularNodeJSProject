import { Component, Input } from '@angular/core';
import { Observable } from 'rxjs';
import { AsyncPipe } from '@angular/common';
import { BreadcrumbComponent } from '../breadcrumb/breadcrumb.component';
import { BreadcrumbItemComponent } from '../breadcrumb-item/breadcrumb-item.component';
import * as i0 from "@angular/core";
import * as i1 from "./breadcrumb-router.service";
export class BreadcrumbRouterComponent {
    constructor(service) {
        this.service = service;
    }
    ngOnInit() {
        this.breadcrumbs = this.service.breadcrumbs$;
    }
    ngOnChanges(changes) {
        if (changes['items']) {
            this.setup();
        }
    }
    setup() {
        if (this.items && this.items.length > 0) {
            this.breadcrumbs = new Observable((observer) => {
                if (this.items) {
                    observer.next(this.items);
                }
            });
        }
    }
    ngOnDestroy() {
        this.breadcrumbs = undefined;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.3", ngImport: i0, type: BreadcrumbRouterComponent, deps: [{ token: i1.BreadcrumbRouterService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "17.2.3", type: BreadcrumbRouterComponent, isStandalone: true, selector: "c-breadcrumb-router, [cBreadcrumbRouter]", inputs: { items: "items" }, usesOnChanges: true, ngImport: i0, template: "<c-breadcrumb class=\"m-0\">\n  @for (breadcrumb of breadcrumbs | async; track breadcrumb; let last = $last) {\n    @if (breadcrumb?.label && (breadcrumb?.url?.slice(-1) === '/' || last)) {\n      <c-breadcrumb-item\n        [active]=\"last\"\n        [url]=\"breadcrumb?.url\"\n        [attributes]=\"breadcrumb?.attributes\"\n        [linkProps]=\"breadcrumb?.linkProps\"\n      >\n        {{ breadcrumb?.label }}\n      </c-breadcrumb-item>\n    }\n  }\n</c-breadcrumb>\n", dependencies: [{ kind: "component", type: BreadcrumbComponent, selector: "c-breadcrumb", inputs: ["ariaLabel", "role"] }, { kind: "component", type: BreadcrumbItemComponent, selector: "c-breadcrumb-item", inputs: ["active", "url", "attributes", "linkProps"] }, { kind: "pipe", type: AsyncPipe, name: "async" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.3", ngImport: i0, type: BreadcrumbRouterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-breadcrumb-router, [cBreadcrumbRouter]', standalone: true, imports: [BreadcrumbComponent, BreadcrumbItemComponent, AsyncPipe], template: "<c-breadcrumb class=\"m-0\">\n  @for (breadcrumb of breadcrumbs | async; track breadcrumb; let last = $last) {\n    @if (breadcrumb?.label && (breadcrumb?.url?.slice(-1) === '/' || last)) {\n      <c-breadcrumb-item\n        [active]=\"last\"\n        [url]=\"breadcrumb?.url\"\n        [attributes]=\"breadcrumb?.attributes\"\n        [linkProps]=\"breadcrumb?.linkProps\"\n      >\n        {{ breadcrumb?.label }}\n      </c-breadcrumb-item>\n    }\n  }\n</c-breadcrumb>\n" }]
        }], ctorParameters: () => [{ type: i1.BreadcrumbRouterService }], propDecorators: { items: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJlYWRjcnVtYi1yb3V0ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZXVpLWFuZ3VsYXIvc3JjL2xpYi9icmVhZGNydW1iL2JyZWFkY3J1bWItcm91dGVyL2JyZWFkY3J1bWItcm91dGVyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2NvcmV1aS1hbmd1bGFyL3NyYy9saWIvYnJlYWRjcnVtYi9icmVhZGNydW1iLXJvdXRlci9icmVhZGNydW1iLXJvdXRlci5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBK0MsTUFBTSxlQUFlLENBQUM7QUFDOUYsT0FBTyxFQUFFLFVBQVUsRUFBWSxNQUFNLE1BQU0sQ0FBQztBQUM1QyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFHNUMsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFFekUsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sOENBQThDLENBQUM7OztBQVF2RixNQUFNLE9BQU8seUJBQXlCO0lBQ3BDLFlBQ1MsT0FBZ0M7UUFBaEMsWUFBTyxHQUFQLE9BQU8sQ0FBeUI7SUFDdEMsQ0FBQztJQVNKLFFBQVE7UUFDTixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDO0lBQy9DLENBQUM7SUFFTSxXQUFXLENBQUMsT0FBc0I7UUFDdkMsSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztZQUNyQixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDZixDQUFDO0lBQ0gsQ0FBQztJQUVELEtBQUs7UUFDSCxJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDeEMsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLFVBQVUsQ0FDL0IsQ0FBQyxRQUFxQyxFQUFFLEVBQUU7Z0JBQ3hDLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO29CQUNmLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUM1QixDQUFDO1lBQ0gsQ0FBQyxDQUNGLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztJQUVELFdBQVc7UUFDVCxJQUFJLENBQUMsV0FBVyxHQUFHLFNBQVMsQ0FBQztJQUMvQixDQUFDOzhHQXBDVSx5QkFBeUI7a0dBQXpCLHlCQUF5QixxSkNmdEMsNGRBY0EsNENERFksbUJBQW1CLHdGQUFFLHVCQUF1QiwrR0FBRSxTQUFTOzsyRkFFdEQseUJBQXlCO2tCQU5yQyxTQUFTOytCQUNFLDBDQUEwQyxjQUV4QyxJQUFJLFdBQ1AsQ0FBQyxtQkFBbUIsRUFBRSx1QkFBdUIsRUFBRSxTQUFTLENBQUM7NEZBV3pELEtBQUs7c0JBQWIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBBc3luY1BpcGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQgeyBJQnJlYWRjcnVtYkl0ZW0gfSBmcm9tICcuLi9icmVhZGNydW1iLWl0ZW0vYnJlYWRjcnVtYi1pdGVtJztcbmltcG9ydCB7IEJyZWFkY3J1bWJDb21wb25lbnQgfSBmcm9tICcuLi9icmVhZGNydW1iL2JyZWFkY3J1bWIuY29tcG9uZW50JztcbmltcG9ydCB7IEJyZWFkY3J1bWJSb3V0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9icmVhZGNydW1iLXJvdXRlci5zZXJ2aWNlJztcbmltcG9ydCB7IEJyZWFkY3J1bWJJdGVtQ29tcG9uZW50IH0gZnJvbSAnLi4vYnJlYWRjcnVtYi1pdGVtL2JyZWFkY3J1bWItaXRlbS5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjLWJyZWFkY3J1bWItcm91dGVyLCBbY0JyZWFkY3J1bWJSb3V0ZXJdJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2JyZWFkY3J1bWItcm91dGVyLmNvbXBvbmVudC5odG1sJyxcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgaW1wb3J0czogW0JyZWFkY3J1bWJDb21wb25lbnQsIEJyZWFkY3J1bWJJdGVtQ29tcG9uZW50LCBBc3luY1BpcGVdXG59KVxuZXhwb3J0IGNsYXNzIEJyZWFkY3J1bWJSb3V0ZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHNlcnZpY2U6IEJyZWFkY3J1bWJSb3V0ZXJTZXJ2aWNlXG4gICkge31cblxuICAvKipcbiAgICogT3B0aW9uYWwgYXJyYXkgb2YgSUJyZWFkY3J1bWJJdGVtIHRvIG92ZXJyaWRlIGRlZmF1bHQgQnJlYWRjcnVtYlJvdXRlciBiZWhhdmlvci4gW2RvY3NdXG4gICAqIEB0eXBlIElCcmVhZGNydW1iSXRlbVtdXG4gICAqL1xuICBASW5wdXQoKSBpdGVtcz86IElCcmVhZGNydW1iSXRlbVtdO1xuICBwdWJsaWMgYnJlYWRjcnVtYnM6IE9ic2VydmFibGU8SUJyZWFkY3J1bWJJdGVtW10+IHwgdW5kZWZpbmVkO1xuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMuYnJlYWRjcnVtYnMgPSB0aGlzLnNlcnZpY2UuYnJlYWRjcnVtYnMkO1xuICB9XG5cbiAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAoY2hhbmdlc1snaXRlbXMnXSkge1xuICAgICAgdGhpcy5zZXR1cCgpO1xuICAgIH1cbiAgfVxuXG4gIHNldHVwKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5icmVhZGNydW1icyA9IG5ldyBPYnNlcnZhYmxlPElCcmVhZGNydW1iSXRlbVtdPihcbiAgICAgICAgKG9ic2VydmVyOiBPYnNlcnZlcjxJQnJlYWRjcnVtYkl0ZW1bXT4pID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh0aGlzLml0ZW1zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5icmVhZGNydW1icyA9IHVuZGVmaW5lZDtcbiAgfVxufVxuIiwiPGMtYnJlYWRjcnVtYiBjbGFzcz1cIm0tMFwiPlxuICBAZm9yIChicmVhZGNydW1iIG9mIGJyZWFkY3J1bWJzIHwgYXN5bmM7IHRyYWNrIGJyZWFkY3J1bWI7IGxldCBsYXN0ID0gJGxhc3QpIHtcbiAgICBAaWYgKGJyZWFkY3J1bWI/LmxhYmVsICYmIChicmVhZGNydW1iPy51cmw/LnNsaWNlKC0xKSA9PT0gJy8nIHx8IGxhc3QpKSB7XG4gICAgICA8Yy1icmVhZGNydW1iLWl0ZW1cbiAgICAgICAgW2FjdGl2ZV09XCJsYXN0XCJcbiAgICAgICAgW3VybF09XCJicmVhZGNydW1iPy51cmxcIlxuICAgICAgICBbYXR0cmlidXRlc109XCJicmVhZGNydW1iPy5hdHRyaWJ1dGVzXCJcbiAgICAgICAgW2xpbmtQcm9wc109XCJicmVhZGNydW1iPy5saW5rUHJvcHNcIlxuICAgICAgPlxuICAgICAgICB7eyBicmVhZGNydW1iPy5sYWJlbCB9fVxuICAgICAgPC9jLWJyZWFkY3J1bWItaXRlbT5cbiAgICB9XG4gIH1cbjwvYy1icmVhZGNydW1iPlxuIl19