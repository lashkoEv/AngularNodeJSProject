import { Component, DestroyRef, EventEmitter, HostBinding, inject, Inject, Input, Output } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { fromEvent } from 'rxjs';
import { filter, finalize, withLatestFrom, zipWith } from 'rxjs/operators';
import { ListenersService } from '../../services';
import { CarouselState } from '../carousel-state';
import { CarouselService } from '../carousel.service';
import { CarouselConfig } from '../carousel.config';
import * as i0 from "@angular/core";
import * as i1 from "../carousel.service";
import * as i2 from "../carousel-state";
import * as i3 from "../../services";
import * as i4 from "../carousel.config";
export class CarouselComponent {
    get hostClasses() {
        return {
            carousel: true,
            slide: true,
            'carousel-dark': !!this.dark,
            'carousel-fade': this.transition === 'crossfade'
        };
    }
    #destroyRef;
    constructor(config, hostElement, carouselService, carouselState, intersectionService, listenersService) {
        this.config = config;
        this.hostElement = hostElement;
        this.carouselService = carouselService;
        this.carouselState = carouselState;
        this.intersectionService = intersectionService;
        this.listenersService = listenersService;
        /**
         * Index of the active item.
         * @type number
         */
        this.activeIndex = 0;
        /**
         * Carousel automatically starts cycle items.
         * @type boolean
         */
        this.animate = true;
        /**
         * Carousel direction. [docs]
         * @type {'next' | 'prev'}
         */
        this.direction = 'next';
        /**
         * The amount of time to delay between automatically cycling an item. If false, carousel will not automatically cycle.
         * @type number
         * @default 0
         */
        this.interval = 0;
        /**
         * Sets which event handlers you’d like provided to your pause prop. You can specify one trigger or an array of them.
         * @type {'hover' | 'focus' | 'click'}
         */
        this.pause = 'hover';
        /**
         * Support left/right swipe interactions on touchscreen devices.
         * @type boolean
         * @default true
         */
        this.touch = true;
        /**
         * Set type of the transition.
         * @type {'slide' | 'crossfade'}
         * @default 'slide'
         */
        this.transition = 'slide';
        /**
         * Set whether the carousel should cycle continuously or have hard stops.
         * @type boolean
         * @default true
         */
        this.wrap = true;
        /**
         * Event emitted on carousel item change. [docs]
         * @type number
         */
        this.itemChange = new EventEmitter();
        this.activeItemInterval = 0;
        this.#destroyRef = inject(DestroyRef);
        this._visible = true;
        Object.assign(this, config);
    }
    ngOnInit() {
        this.carouselStateSubscribe();
    }
    ngOnDestroy() {
        this.resetTimer();
        this.clearListeners();
        this.swipeSubscribe(false);
    }
    ngAfterContentInit() {
        this.intersectionServiceSubscribe();
        this.carouselState.state = { activeItemIndex: this.activeIndex, animate: this.animate };
        this.setListeners();
        this.swipeSubscribe();
    }
    setListeners() {
        const config = {
            hostElement: this.hostElement,
            trigger: this.pause || [],
            callbackOff: () => {
                this.setTimer();
            },
            callbackOn: () => {
                this.resetTimer();
            }
        };
        this.listenersService.setListeners(config);
    }
    clearListeners() {
        this.listenersService.clearListeners();
    }
    set visible(value) {
        this._visible = value;
    }
    get visible() {
        return this._visible;
    }
    setTimer() {
        const interval = this.activeItemInterval || 0;
        this.resetTimer();
        if (interval > 0) {
            this.timerId = setTimeout(() => {
                const nextIndex = this.carouselState.direction(this.direction);
                this.carouselState.state = { activeItemIndex: nextIndex };
            }, interval);
        }
    }
    resetTimer() {
        clearTimeout(this.timerId);
        this.timerId = undefined;
    }
    carouselStateSubscribe() {
        this.carouselService.carouselIndex$
            .pipe(takeUntilDestroyed(this.#destroyRef))
            .subscribe((nextItem) => {
            if ('active' in nextItem) {
                this.itemChange.emit(nextItem.active);
            }
            this.activeItemInterval = typeof nextItem.interval === 'number' && nextItem.interval > -1 ? nextItem.interval : this.interval;
            const isLastItem = ((nextItem.active === nextItem.lastItemIndex) && this.direction === 'next') || ((nextItem.active === 0) && this.direction === 'prev');
            !this.wrap && isLastItem ? this.resetTimer() : this.setTimer();
        });
    }
    intersectionServiceSubscribe() {
        this.intersectionService.intersecting$
            .pipe(filter(next => next.hostElement === this.hostElement), finalize(() => {
            this.intersectionService.unobserve(this.hostElement);
        }), takeUntilDestroyed(this.#destroyRef))
            .subscribe(next => {
            this.visible = next.isIntersecting;
            next.isIntersecting ? this.setTimer() : this.resetTimer();
        });
        this.intersectionService.createIntersectionObserver(this.hostElement);
    }
    swipeSubscribe(subscribe = true) {
        if (this.touch && subscribe) {
            const carouselElement = this.hostElement.nativeElement;
            const touchStart$ = fromEvent(carouselElement, 'touchstart');
            const touchEnd$ = fromEvent(carouselElement, 'touchend');
            const touchMove$ = fromEvent(carouselElement, 'touchmove');
            this.swipeSubscription = touchStart$.pipe(zipWith(touchEnd$.pipe(withLatestFrom(touchMove$))), takeUntilDestroyed(this.#destroyRef))
                .subscribe(([touchstart, [touchend, touchmove]]) => {
                touchstart.stopPropagation();
                touchmove.stopPropagation();
                const distanceX = touchstart.touches[0].clientX - touchmove.touches[0].clientX;
                if (Math.abs(distanceX) > 0.3 * carouselElement.clientWidth && touchstart.timeStamp <= touchmove.timeStamp) {
                    const nextIndex = this.carouselState.direction(distanceX > 0 ? 'next' : 'prev');
                    this.carouselState.state = { activeItemIndex: nextIndex };
                }
            });
        }
        else {
            this.swipeSubscription?.unsubscribe();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: CarouselComponent, deps: [{ token: CarouselConfig }, { token: i0.ElementRef }, { token: i1.CarouselService }, { token: i2.CarouselState }, { token: i3.IntersectionService }, { token: i3.ListenersService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.1", type: CarouselComponent, isStandalone: true, selector: "c-carousel", inputs: { activeIndex: "activeIndex", animate: "animate", dark: "dark", direction: "direction", interval: "interval", pause: "pause", touch: "touch", transition: "transition", wrap: "wrap" }, outputs: { itemChange: "itemChange" }, host: { properties: { "class": "this.hostClasses" } }, providers: [CarouselService, CarouselState, CarouselConfig, ListenersService], ngImport: i0, template: '<ng-content></ng-content>', isInline: true, styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.1", ngImport: i0, type: CarouselComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel', template: '<ng-content></ng-content>', providers: [CarouselService, CarouselState, CarouselConfig, ListenersService], standalone: true, styles: [":host{display:block}\n"] }]
        }], ctorParameters: () => [{ type: i4.CarouselConfig, decorators: [{
                    type: Inject,
                    args: [CarouselConfig]
                }] }, { type: i0.ElementRef }, { type: i1.CarouselService }, { type: i2.CarouselState }, { type: i3.IntersectionService }, { type: i3.ListenersService }], propDecorators: { activeIndex: [{
                type: Input
            }], animate: [{
                type: Input
            }], dark: [{
                type: Input
            }], direction: [{
                type: Input
            }], interval: [{
                type: Input
            }], pause: [{
                type: Input
            }], touch: [{
                type: Input
            }], transition: [{
                type: Input
            }], wrap: [{
                type: Input
            }], itemChange: [{
                type: Output
            }], hostClasses: [{
                type: HostBinding,
                args: ['class']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvY29yZXVpLWFuZ3VsYXIvc3JjL2xpYi9jYXJvdXNlbC9jYXJvdXNlbC9jYXJvdXNlbC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLFNBQVMsRUFDVCxVQUFVLEVBRVYsWUFBWSxFQUNaLFdBQVcsRUFDWCxNQUFNLEVBQ04sTUFBTSxFQUNOLEtBQUssRUFHTCxNQUFNLEVBQ1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDaEUsT0FBTyxFQUFFLFNBQVMsRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDL0MsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLE9BQU8sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRzNFLE9BQU8sRUFBb0IsZ0JBQWdCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVwRSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDbEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQzs7Ozs7O0FBVXBELE1BQU0sT0FBTyxpQkFBaUI7SUF3RDVCLElBQ0ksV0FBVztRQUNiLE9BQU87WUFDTCxRQUFRLEVBQUUsSUFBSTtZQUNkLEtBQUssRUFBRSxJQUFJO1lBQ1gsZUFBZSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSTtZQUM1QixlQUFlLEVBQUUsSUFBSSxDQUFDLFVBQVUsS0FBSyxXQUFXO1NBQ2pELENBQUM7SUFDSixDQUFDO0lBS1EsV0FBVyxDQUFzQjtJQUUxQyxZQUNrQyxNQUFzQixFQUM5QyxXQUF1QixFQUN2QixlQUFnQyxFQUNoQyxhQUE0QixF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QXdFbEIsY0FBYztrR0F4RWIsaUJBQWlCLHVWQUhqQixDQUFDLGVBQWUsRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixDQUFDLDBCQUZuRSwyQkFBMkI7OzJGQUsxQixpQkFBaUI7a0JBUDdCLFNBQVM7K0JBQ0UsWUFBWSxZQUNaLDJCQUEyQixhQUUxQixDQUFDLGVBQWUsRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixDQUFDLGNBQ2pFLElBQUk7OzBCQTBFYixNQUFNOzJCQUFDLGNBQWM7NkxBbkVmLFdBQVc7c0JBQW5CLEtBQUs7Z0JBS0csT0FBTztzQkFBZixLQUFLO2dCQUtHLElBQUk7c0JBQVosS0FBSztnQkFLRyxTQUFTO3NCQUFqQixLQUFLO2dCQU1HLFFBQVE7c0JBQWhCLEtBQUs7Z0JBS0csS0FBSztzQkFBYixLQUFLO2dCQU1HLEtBQUs7c0JBQWIsS0FBSztnQkFNRyxVQUFVO3NCQUFsQixLQUFLO2dCQU1HLElBQUk7c0JBQVosS0FBSztnQkFLSSxVQUFVO3NCQUFuQixNQUFNO2dCQUdILFdBQVc7c0JBRGQsV0FBVzt1QkFBQyxPQUFPIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ29tcG9uZW50LFxuICBEZXN0cm95UmVmLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RCaW5kaW5nLFxuICBpbmplY3QsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0YWtlVW50aWxEZXN0cm95ZWQgfSBmcm9tICdAYW5ndWxhci9jb3JlL3J4anMtaW50ZXJvcCc7XG5pbXBvcnQgeyBmcm9tRXZlbnQsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCBmaW5hbGl6ZSwgd2l0aExhdGVzdEZyb20sIHppcFdpdGggfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IEludGVyc2VjdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcyc7XG5pbXBvcnQgeyBJTGlzdGVuZXJzQ29uZmlnLCBMaXN0ZW5lcnNTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMnO1xuXG5pbXBvcnQgeyBDYXJvdXNlbFN0YXRlIH0gZnJvbSAnLi4vY2Fyb3VzZWwtc3RhdGUnO1xuaW1wb3J0IHsgQ2Fyb3VzZWxTZXJ2aWNlIH0gZnJvbSAnLi4vY2Fyb3VzZWwuc2VydmljZSc7XG5pbXBvcnQgeyBDYXJvdXNlbENvbmZpZyB9IGZyb20gJy4uL2Nhcm91c2VsLmNvbmZpZyc7XG5pbXBvcnQgeyBUcmlnZ2VycyB9IGZyb20gJy4uLy4uL2NvcmV1aS50eXBlcyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2MtY2Fyb3VzZWwnLFxuICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICBzdHlsZVVybHM6IFsnLi9jYXJvdXNlbC5jb21wb25lbnQuc2NzcyddLFxuICBwcm92aWRlcnM6IFtDYXJvdXNlbFNlcnZpY2UsIENhcm91c2VsU3RhdGUsIENhcm91c2VsQ29uZmlnLCBMaXN0ZW5lcnNTZXJ2aWNlXSxcbiAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBDYXJvdXNlbENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95LCBBZnRlckNvbnRlbnRJbml0IHtcbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBhY3RpdmUgaXRlbS5cbiAgICogQHR5cGUgbnVtYmVyXG4gICAqL1xuICBASW5wdXQoKSBhY3RpdmVJbmRleDogbnVtYmVyID0gMDtcbiAgLyoqXG4gICAqIENhcm91c2VsIGF1dG9tYXRpY2FsbHkgc3RhcnRzIGN5Y2xlIGl0ZW1zLlxuICAgKiBAdHlwZSBib29sZWFuXG4gICAqL1xuICBASW5wdXQoKSBhbmltYXRlOiBib29sZWFuID0gdHJ1ZTtcbiAgLyoqXG4gICAqIEFkZCBkYXJrZXIgY29udHJvbHMsIGluZGljYXRvcnMsIGFuZCBjYXB0aW9ucy5cbiAgICogQHR5cGUgYm9vbGVhblxuICAgKi9cbiAgQElucHV0KCkgZGFyaz86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBDYXJvdXNlbCBkaXJlY3Rpb24uIFtkb2NzXVxuICAgKiBAdHlwZSB7J25leHQnIHwgJ3ByZXYnfVxuICAgKi9cbiAgQElucHV0KCkgZGlyZWN0aW9uOiAnbmV4dCcgfCAncHJldicgPSAnbmV4dCc7XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgYmV0d2VlbiBhdXRvbWF0aWNhbGx5IGN5Y2xpbmcgYW4gaXRlbS4gSWYgZmFsc2UsIGNhcm91c2VsIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgY3ljbGUuXG4gICAqIEB0eXBlIG51bWJlclxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBASW5wdXQoKSBpbnRlcnZhbDogbnVtYmVyID0gMDtcbiAgLyoqXG4gICAqIFNldHMgd2hpY2ggZXZlbnQgaGFuZGxlcnMgeW914oCZZCBsaWtlIHByb3ZpZGVkIHRvIHlvdXIgcGF1c2UgcHJvcC4gWW91IGNhbiBzcGVjaWZ5IG9uZSB0cmlnZ2VyIG9yIGFuIGFycmF5IG9mIHRoZW0uXG4gICAqIEB0eXBlIHsnaG92ZXInIHwgJ2ZvY3VzJyB8ICdjbGljayd9XG4gICAqL1xuICBASW5wdXQoKSBwYXVzZTogVHJpZ2dlcnMgfCBUcmlnZ2Vyc1tdIHwgZmFsc2UgPSAnaG92ZXInO1xuICAvKipcbiAgICogU3VwcG9ydCBsZWZ0L3JpZ2h0IHN3aXBlIGludGVyYWN0aW9ucyBvbiB0b3VjaHNjcmVlbiBkZXZpY2VzLlxuICAgKiBAdHlwZSBib29sZWFuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIEBJbnB1dCgpIHRvdWNoOiBib29sZWFuID0gdHJ1ZTtcbiAgLyoqXG4gICAqIFNldCB0eXBlIG9mIHRoZSB0cmFuc2l0aW9uLlxuICAgKiBAdHlwZSB7J3NsaWRlJyB8ICdjcm9zc2ZhZGUnfVxuICAgKiBAZGVmYXVsdCAnc2xpZGUnXG4gICAqL1xuICBASW5wdXQoKSB0cmFuc2l0aW9uOiAnc2xpZGUnIHwgJ2Nyb3NzZmFkZScgPSAnc2xpZGUnO1xuICAvKipcbiAgICogU2V0IHdoZXRoZXIgdGhlIGNhcm91c2VsIHNob3VsZCBjeWNsZSBjb250aW51b3VzbHkgb3IgaGF2ZSBoYXJkIHN0b3BzLlxuICAgKiBAdHlwZSBib29sZWFuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIEBJbnB1dCgpIHdyYXA6IGJvb2xlYW4gPSB0cnVlO1xuICAvKipcbiAgICogRXZlbnQgZW1pdHRlZCBvbiBjYXJvdXNlbCBpdGVtIGNoYW5nZS4gW2RvY3NdXG4gICAqIEB0eXBlIG51bWJlclxuICAgKi9cbiAgQE91dHB1dCgpIGl0ZW1DaGFuZ2U6IEV2ZW50RW1pdHRlcjxudW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcycpXG4gIGdldCBob3N0Q2xhc3NlcygpOiBhbnkge1xuICAgIHJldHVybiB7XG4gICAgICBjYXJvdXNlbDogdHJ1ZSxcbiAgICAgIHNsaWRlOiB0cnVlLFxuICAgICAgJ2Nhcm91c2VsLWRhcmsnOiAhIXRoaXMuZGFyayxcbiAgICAgICdjYXJvdXNlbC1mYWRlJzogdGhpcy50cmFuc2l0aW9uID09PSAnY3Jvc3NmYWRlJ1xuICAgIH07XG4gIH1cblxuICBwcml2YXRlIHRpbWVySWQ6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIGFjdGl2ZUl0ZW1JbnRlcnZhbCA9IDA7XG4gIHByaXZhdGUgc3dpcGVTdWJzY3JpcHRpb24/OiBTdWJzY3JpcHRpb247XG4gIHJlYWRvbmx5ICNkZXN0cm95UmVmID0gaW5qZWN0KERlc3Ryb3lSZWYpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoQ2Fyb3VzZWxDb25maWcpIHByaXZhdGUgY29uZmlnOiBDYXJvdXNlbENvbmZpZyxcbiAgICBwcml2YXRlIGhvc3RFbGVtZW50OiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgY2Fyb3VzZWxTZXJ2aWNlOiBDYXJvdXNlbFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBjYXJvdXNlbFN0YXRlOiBDYXJvdXNlbFN0YXRlLFxuICAgIHByaXZhdGUgaW50ZXJzZWN0aW9uU2VydmljZTogSW50ZXJzZWN0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIGxpc3RlbmVyc1NlcnZpY2U6IExpc3RlbmVyc1NlcnZpY2VcbiAgKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWcpO1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5jYXJvdXNlbFN0YXRlU3Vic2NyaWJlKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnJlc2V0VGltZXIoKTtcbiAgICB0aGlzLmNsZWFyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5zd2lwZVN1YnNjcmliZShmYWxzZSk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5pbnRlcnNlY3Rpb25TZXJ2aWNlU3Vic2NyaWJlKCk7XG4gICAgdGhpcy5jYXJvdXNlbFN0YXRlLnN0YXRlID0geyBhY3RpdmVJdGVtSW5kZXg6IHRoaXMuYWN0aXZlSW5kZXgsIGFuaW1hdGU6IHRoaXMuYW5pbWF0ZSB9O1xuICAgIHRoaXMuc2V0TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5zd2lwZVN1YnNjcmliZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgY29uc3QgY29uZmlnOiBJTGlzdGVuZXJzQ29uZmlnID0ge1xuICAgICAgaG9zdEVsZW1lbnQ6IHRoaXMuaG9zdEVsZW1lbnQsXG4gICAgICB0cmlnZ2VyOiB0aGlzLnBhdXNlIHx8IFtdLFxuICAgICAgY2FsbGJhY2tPZmY6ICgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRUaW1lcigpO1xuICAgICAgfSxcbiAgICAgIGNhbGxiYWNrT246ICgpID0+IHtcbiAgICAgICAgdGhpcy5yZXNldFRpbWVyKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmxpc3RlbmVyc1NlcnZpY2Uuc2V0TGlzdGVuZXJzKGNvbmZpZyk7XG4gIH1cblxuICBwcml2YXRlIGNsZWFyTGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIHRoaXMubGlzdGVuZXJzU2VydmljZS5jbGVhckxpc3RlbmVycygpO1xuICB9XG5cbiAgc2V0IHZpc2libGUodmFsdWUpIHtcbiAgICB0aGlzLl92aXNpYmxlID0gdmFsdWU7XG4gIH1cblxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgfVxuXG4gIHByaXZhdGUgX3Zpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIHNldFRpbWVyKCk6IHZvaWQge1xuICAgIGNvbnN0IGludGVydmFsID0gdGhpcy5hY3RpdmVJdGVtSW50ZXJ2YWwgfHwgMDtcbiAgICB0aGlzLnJlc2V0VGltZXIoKTtcbiAgICBpZiAoaW50ZXJ2YWwgPiAwKSB7XG4gICAgICB0aGlzLnRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gdGhpcy5jYXJvdXNlbFN0YXRlLmRpcmVjdGlvbih0aGlzLmRpcmVjdGlvbik7XG4gICAgICAgIHRoaXMuY2Fyb3VzZWxTdGF0ZS5zdGF0ZSA9IHsgYWN0aXZlSXRlbUluZGV4OiBuZXh0SW5kZXggfTtcbiAgICAgIH0sIGludGVydmFsKTtcbiAgICB9XG4gIH1cblxuICByZXNldFRpbWVyKCk6IHZvaWQge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgIHRoaXMudGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHByaXZhdGUgY2Fyb3VzZWxTdGF0ZVN1YnNjcmliZSgpOiB2b2lkIHtcbiAgICB0aGlzLmNhcm91c2VsU2VydmljZS5jYXJvdXNlbEluZGV4JFxuICAgICAgLnBpcGUoXG4gICAgICAgIHRha2VVbnRpbERlc3Ryb3llZCh0aGlzLiNkZXN0cm95UmVmKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgobmV4dEl0ZW0pID0+IHtcbiAgICAgICAgaWYgKCdhY3RpdmUnIGluIG5leHRJdGVtKSB7XG4gICAgICAgICAgdGhpcy5pdGVtQ2hhbmdlLmVtaXQobmV4dEl0ZW0uYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZUl0ZW1JbnRlcnZhbCA9IHR5cGVvZiBuZXh0SXRlbS5pbnRlcnZhbCA9PT0gJ251bWJlcicgJiYgbmV4dEl0ZW0uaW50ZXJ2YWwgPiAtMSA/IG5leHRJdGVtLmludGVydmFsIDogdGhpcy5pbnRlcnZhbDtcbiAgICAgICAgY29uc3QgaXNMYXN0SXRlbSA9ICgobmV4dEl0ZW0uYWN0aXZlID09PSBuZXh0SXRlbS5sYXN0SXRlbUluZGV4KSAmJiB0aGlzLmRpcmVjdGlvbiA9PT0gJ25leHQnKSB8fCAoKG5leHRJdGVtLmFjdGl2ZSA9PT0gMCkgJiYgdGhpcy5kaXJlY3Rpb24gPT09ICdwcmV2Jyk7XG4gICAgICAgICF0aGlzLndyYXAgJiYgaXNMYXN0SXRlbSA/IHRoaXMucmVzZXRUaW1lcigpIDogdGhpcy5zZXRUaW1lcigpO1xuICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGludGVyc2VjdGlvblNlcnZpY2VTdWJzY3JpYmUoKTogdm9pZCB7XG4gICAgdGhpcy5pbnRlcnNlY3Rpb25TZXJ2aWNlLmludGVyc2VjdGluZyRcbiAgICAgIC5waXBlKFxuICAgICAgICBmaWx0ZXIobmV4dCA9PiBuZXh0Lmhvc3RFbGVtZW50ID09PSB0aGlzLmhvc3RFbGVtZW50KSxcbiAgICAgICAgZmluYWxpemUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uU2VydmljZS51bm9ic2VydmUodGhpcy5ob3N0RWxlbWVudCk7XG4gICAgICAgIH0pLFxuICAgICAgICB0YWtlVW50aWxEZXN0cm95ZWQodGhpcy4jZGVzdHJveVJlZilcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUobmV4dCA9PiB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IG5leHQuaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgIG5leHQuaXNJbnRlcnNlY3RpbmcgPyB0aGlzLnNldFRpbWVyKCkgOiB0aGlzLnJlc2V0VGltZXIoKTtcbiAgICAgIH0pO1xuICAgIHRoaXMuaW50ZXJzZWN0aW9uU2VydmljZS5jcmVhdGVJbnRlcnNlY3Rpb25PYnNlcnZlcih0aGlzLmhvc3RFbGVtZW50KTtcbiAgfVxuXG4gIHByaXZhdGUgc3dpcGVTdWJzY3JpYmUoc3Vic2NyaWJlOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLnRvdWNoICYmIHN1YnNjcmliZSkge1xuICAgICAgY29uc3QgY2Fyb3VzZWxFbGVtZW50ID0gdGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgY29uc3QgdG91Y2hTdGFydCQgPSBmcm9tRXZlbnQ8VG91Y2hFdmVudD4oY2Fyb3VzZWxFbGVtZW50LCAndG91Y2hzdGFydCcpO1xuICAgICAgY29uc3QgdG91Y2hFbmQkID0gZnJvbUV2ZW50PFRvdWNoRXZlbnQ+KGNhcm91c2VsRWxlbWVudCwgJ3RvdWNoZW5kJyk7XG4gICAgICBjb25zdCB0b3VjaE1vdmUkID0gZnJvbUV2ZW50PFRvdWNoRXZlbnQ+KGNhcm91c2VsRWxlbWVudCwgJ3RvdWNobW92ZScpO1xuICAgICAgdGhpcy5zd2lwZVN1YnNjcmlwdGlvbiA9IHRvdWNoU3RhcnQkLnBpcGUoXG4gICAgICAgIHppcFdpdGgodG91Y2hFbmQkLnBpcGUod2l0aExhdGVzdEZyb20odG91Y2hNb3ZlJCkpKSxcbiAgICAgICAgdGFrZVVudGlsRGVzdHJveWVkKHRoaXMuI2Rlc3Ryb3lSZWYpXG4gICAgICApXG4gICAgICAgIC5zdWJzY3JpYmUoKFt0b3VjaHN0YXJ0LCBbdG91Y2hlbmQsIHRvdWNobW92ZV1dKSA9PiB7XG4gICAgICAgICAgdG91Y2hzdGFydC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB0b3VjaG1vdmUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgY29uc3QgZGlzdGFuY2VYID0gdG91Y2hzdGFydC50b3VjaGVzWzBdLmNsaWVudFggLSB0b3VjaG1vdmUudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZVgpID4gMC4zICogY2Fyb3VzZWxFbGVtZW50LmNsaWVudFdpZHRoICYmIHRvdWNoc3RhcnQudGltZVN0YW1wIDw9IHRvdWNobW92ZS50aW1lU3RhbXApIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHRoaXMuY2Fyb3VzZWxTdGF0ZS5kaXJlY3Rpb24oZGlzdGFuY2VYID4gMCA/ICduZXh0JyA6ICdwcmV2Jyk7XG4gICAgICAgICAgICB0aGlzLmNhcm91c2VsU3RhdGUuc3RhdGUgPSB7IGFjdGl2ZUl0ZW1JbmRleDogbmV4dEluZGV4IH07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zd2lwZVN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==